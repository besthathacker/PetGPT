<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PetGPT Ultimate</title>
<style>
  /* ... same styles as before ... */
  * { box-sizing: border-box; margin: 0; padding: 0; font-family: Arial, sans-serif; }
  body {
    display: flex;
    height: 100vh;
    background: #121212;
    color: #eee;
    overflow: hidden;
  }
  /* Sidebar */
  #sidebar {
    width: 280px;
    background: #222;
    padding: 16px;
    border-right: 2px solid #333;
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-y: auto;
  }
  #sidebar h2 {
    color: #0ff;
    margin-bottom: 8px;
  }
  #sidebar label {
    display: block;
    margin-bottom: 6px;
    font-weight: bold;
  }
  #sidebar input[type="file"], #sidebar select, #sidebar button {
    width: 100%;
    padding: 8px;
    background: #333;
    border: 1px solid #444;
    color: #eee;
    border-radius: 4px;
    cursor: pointer;
  }
  #sidebar button {
    background: #0a84ff;
    border: none;
    margin-top: 6px;
  }
  #sidebar button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  #filePreview {
    margin-top: 10px;
    font-size: 12px;
    max-height: 150px;
    overflow-y: auto;
    background: #111;
    border: 1px solid #333;
    padding: 6px;
    white-space: pre-wrap;
    word-break: break-word;
  }
  #filePreview img {
    max-width: 100%;
    margin-top: 8px;
    border-radius: 4px;
  }

  /* Main */
  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #181818;
  }
  header, footer {
    background: #004488;
    padding: 12px;
    text-align: center;
    font-weight: bold;
    color: #ccf;
  }
  #chatTabs {
    display: flex;
    background: #222;
    border-bottom: 1px solid #333;
    overflow-x: auto;
  }
  .tab {
    padding: 8px 14px;
    cursor: pointer;
    user-select: none;
    border-right: 1px solid #333;
    color: #ccc;
    position: relative;
  }
  .tab.active {
    background: #0a84ff;
    color: #fff;
    font-weight: bold;
  }
  .tab .close-btn {
    position: absolute;
    top: 4px;
    right: 4px;
    font-weight: bold;
    cursor: pointer;
    color: #fff;
  }
  .tab .rename-btn {
    position: absolute;
    top: 4px;
    right: 20px;
    font-weight: bold;
    cursor: pointer;
    color: #fff;
  }

  #chatContainer {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    background: #121212;
  }
  .message {
    margin-bottom: 12px;
    max-width: 70%;
    padding: 10px 14px;
    border-radius: 10px;
    line-height: 1.3;
    word-wrap: break-word;
  }
  .message.user {
    background: #0a84ff;
    color: #fff;
    margin-left: auto;
    border-bottom-right-radius: 0;
  }
  .message.bot {
    background: #333;
    color: #eee;
    margin-right: auto;
    border-bottom-left-radius: 0;
  }

  #inputArea {
    display: flex;
    padding: 12px;
    background: #222;
  }
  #userInput {
    flex: 1;
    padding: 10px;
    font-size: 1rem;
    border-radius: 6px;
    border: none;
    background: #111;
    color: #eee;
  }
  #sendBtn {
    margin-left: 10px;
    padding: 10px 20px;
    background: #0a84ff;
    border: none;
    color: #fff;
    font-weight: bold;
    border-radius: 6px;
    cursor: pointer;
  }
  #sendBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Voice chat */
  #voiceControls {
    margin-top: 12px;
    display: flex;
    gap: 10px;
  }
  #voiceStart, #voiceStop {
    flex: 1;
    padding: 8px;
    border-radius: 5px;
    border: none;
    cursor: pointer;
    font-weight: bold;
    background: #0a84ff;
    color: white;
  }
  #voiceStop {
    background: #bb2222;
  }
  #voiceStop:disabled, #voiceStart:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Personality */
  #personality {
    margin-top: 12px;
    background: #222;
    border-radius: 6px;
    padding: 10px;
  }
  #personality label {
    display: block;
    margin-bottom: 6px;
    font-weight: bold;
  }
  #personality select {
    width: 100%;
    padding: 8px;
    border-radius: 5px;
    background: #111;
    color: #eee;
    border: 1px solid #444;
  }

  /* Model selector */
  #modelSelector {
    margin-top: 12px;
  }
  #modelSelector label {
    font-weight: bold;
    display: block;
    margin-bottom: 6px;
  }
  #modelSelector select {
    width: 100%;
    padding: 8px;
    border-radius: 5px;
    background: #111;
    color: #eee;
    border: 1px solid #444;
  }

</style>
</head>
<body>

<div id="sidebar" role="complementary" aria-label="Sidebar with controls">
  <h2>üìé File Upload & DeepAI</h2>
  <label for="fileInput">Upload File</label>
  <input type="file" id="fileInput" aria-describedby="filePreview" />
  <button id="analyzeBtn" disabled>Analyze File</button>
  <button id="editImageBtn" disabled>Edit Image</button>
  <button id="generateImageBtn">Generate Image (Text Prompt)</button>
  <div id="filePreview" aria-live="polite" aria-atomic="true"></div>

  <div id="voiceControls">
    <button id="voiceStart" aria-label="Start voice input">üéôÔ∏è Start Voice</button>
    <button id="voiceStop" aria-label="Stop voice input" disabled>‚èπÔ∏è Stop Voice</button>
  </div>

  <div id="personality">
    <label for="personalitySelect">Personality</label>
    <select id="personalitySelect" aria-label="Select chatbot personality">
      <option value="friendly">Friendly</option>
      <option value="roast">Roast</option>
    </select>
  </div>

  <div id="modelSelector">
    <label for="modelSelect">AI Model</label>
    <select id="modelSelect" aria-label="Select AI model">
      <option value="gpt2">GPT-2 Small</option>
      <option value="gpt2-medium">GPT-2 Medium</option>
      <option value="gpt2-large">GPT-2 Large</option>
      <option value="gpt2-xl">GPT-2 XL</option>
      <option value="deepai-textgen">DeepAI Text Gen</option>
    </select>
  </div>
</div>

<div id="main" role="main">
  <header>
    <h1>üêæ PetGPT Ultimate</h1>
  </header>

  <div id="chatTabs" role="tablist" aria-label="Chat sessions"></div>
  <div id="chatContainer" role="region" aria-live="polite" aria-label="Chat messages"></div>

  <div id="inputArea">
    <input id="userInput" type="text" placeholder="Type your message..." aria-label="User input" autocomplete="off" />
    <button id="sendBtn" aria-label="Send message">Send</button>
  </div>

  <footer>
    <small>¬© 2025 PetGPT Ultimate</small>
  </footer>
</div>

<script type="module">
  // ---- Globals & Storage keys ----
  const DEEPAI_API_KEY = '8c839b12-749b-46be-a333-404236941b8b';

  const STORAGE_KEY = 'petgpt-multichats';
  const STORAGE_PERSONALITY_KEY = 'petgpt-personality';
  const STORAGE_MODEL_KEY = 'petgpt-model';
  const STORAGE_ACTIVE_CHAT_KEY = 'petgpt-active-chat';

  // ---- Elements ----
  const fileInput = document.getElementById('fileInput');
  const analyzeBtn = document.getElementById('analyzeBtn');
  const editImageBtn = document.getElementById('editImageBtn');
  const generateImageBtn = document.getElementById('generateImageBtn');
  const filePreview = document.getElementById('filePreview');
  const voiceStartBtn = document.getElementById('voiceStart');
  const voiceStopBtn = document.getElementById('voiceStop');
  const personalitySelect = document.getElementById('personalitySelect');
  const modelSelect = document.getElementById('modelSelect');

  const chatTabs = document.getElementById('chatTabs');
  const chatContainer = document.getElementById('chatContainer');
  const userInput = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');

  // ---- State ----
  let chats = {}; // { chatId: { name, messages: [ {from, text} ] } }
  let activeChatId = null;
  let recognition = null;
  let listening = false;
  let personality = 'friendly';
  let model = 'gpt2';
  let localGPT2Pipeline = null;

  // ---- Helpers ----

  // Save chats to localStorage
  function saveChats() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(chats));
  }

  // Load chats from localStorage
  function loadChats() {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      chats = JSON.parse(stored);
      if (Object.keys(chats).length > 0) {
        activeChatId = localStorage.getItem(STORAGE_ACTIVE_CHAT_KEY) || Object.keys(chats)[0];
      }
    }
  }

  // Save personality and model
  function savePersonality() {
    localStorage.setItem(STORAGE_PERSONALITY_KEY, personality);
  }
  function saveModel() {
    localStorage.setItem(STORAGE_MODEL_KEY, model);
  }

  // Render chat tabs
  function renderTabs() {
    chatTabs.innerHTML = '';
    for (const id of Object.keys(chats)) {
      const tab = document.createElement('div');
      tab.className = 'tab';
      if (id === activeChatId) tab.classList.add('active');
      tab.textContent = chats[id].name || 'Chat';
      tab.setAttribute('role', 'tab');
      tab.setAttribute('tabindex', id === activeChatId ? '0' : '-1');
      tab.dataset.chatId = id;

      // Rename button
      const renameBtn = document.createElement('span');
      renameBtn.textContent = '‚úé';
      renameBtn.title = 'Rename chat';
      renameBtn.className = 'rename-btn';
      renameBtn.addEventListener('click', e => {
        e.stopPropagation();
        const newName = prompt('Enter new chat name:', chats[id].name);
        if (newName && newName.trim().length > 0) {
          chats[id].name = newName.trim();
          saveChats();
          renderTabs();
          renderMessages();
        }
      });
      tab.appendChild(renameBtn);

      // Close/Delete button
      const closeBtn = document.createElement('span');
      closeBtn.textContent = '√ó';
      closeBtn.title = 'Delete chat';
      closeBtn.className = 'close-btn';
      closeBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (confirm(`Delete chat "${chats[id].name}"? This cannot be undone.`)) {
          delete chats[id];
          if (activeChatId === id) {
            activeChatId = Object.keys(chats)[0] || null;
          }
          saveChats();
          renderTabs();
          renderMessages();
        }
      });
      tab.appendChild(closeBtn);

      tab.addEventListener('click', () => {
        if (activeChatId !== id) {
          activeChatId = id;
          saveActiveChat();
          renderTabs();
          renderMessages();
        }
      });
      chatTabs.appendChild(tab);
    }

    // Add new chat tab
    const newTab = document.createElement('div');
    newTab.className = 'tab';
    newTab.textContent = '+ New Chat';
    newTab.title = 'Start a new chat';
    newTab.addEventListener('click', () => {
      const newId = 'chat-' + Date.now();
      chats[newId] = { name: 'New Chat', messages: [] };
      activeChatId = newId;
      saveChats();
      saveActiveChat();
      renderTabs();
      renderMessages();
    });
    chatTabs.appendChild(newTab);
  }

  function saveActiveChat() {
    if (activeChatId) localStorage.setItem(STORAGE_ACTIVE_CHAT_KEY, activeChatId);
  }

  // Render chat messages for active chat
  function renderMessages() {
    chatContainer.innerHTML = '';
    if (!activeChatId || !chats[activeChatId]) {
      chatContainer.textContent = 'No active chat. Please create a new chat.';
      return;
    }
    for (const msg of chats[activeChatId].messages) {
      const div = document.createElement('div');
      div.className = 'message ' + (msg.from === 'user' ? 'user' : 'bot');
      div.textContent = msg.text;
      chatContainer.appendChild(div);
    }
    chatContainer.scrollTop = chatContainer.scrollHeight;
  }

  // Append a message to active chat and re-render
  function appendMessage(from, text) {
    if (!activeChatId) return;
    chats[activeChatId].messages.push({ from, text });
    saveChats();
    renderMessages();
  }

  // Clear file preview and reset buttons
  function resetFilePreview() {
    filePreview.innerHTML = '';
    analyzeBtn.disabled = true;
    editImageBtn.disabled = true;
  }

  // Auto-detect file type and show preview
  function handleFilePreview(file) {
    resetFilePreview();

    if (!file) return;

    const type = file.type;
    if (type.startsWith('image/')) {
      // Show image preview
      const img = document.createElement('img');
      img.src = URL.createObjectURL(file);
      filePreview.appendChild(img);
      analyzeBtn.disabled = true;
      editImageBtn.disabled = false;
    } else if (type === 'application/pdf') {
      // Show PDF filename (we won‚Äôt render content in browser)
      filePreview.textContent = `PDF File: ${file.name} (Upload to analyze)`;
      analyzeBtn.disabled = false;
      editImageBtn.disabled = true;
    } else if (
      type.startsWith('text/') ||
      file.name.match(/\.(js|py|java|c|cpp|html|css|json|md|ts|sh)$/i)
    ) {
      // Try to read as text and show snippet
      const reader = new FileReader();
      reader.onload = () => {
        let text = reader.result;
        if (text.length > 1000) text = text.slice(0, 1000) + '\n...';
        filePreview.textContent = `Code/Text file preview:\n\n` + text;
        analyzeBtn.disabled = true;
        editImageBtn.disabled = true;
      };
      reader.readAsText(file);
    } else {
      filePreview.textContent = `Unsupported file type: ${type || 'unknown'}`;
      analyzeBtn.disabled = true;
      editImageBtn.disabled = true;
    }
  }

  // ---- DeepAI API calls ----

  async function deepaiRequest(endpoint, body) {
    const res = await fetch(`https://api.deepai.org/api/${endpoint}`, {
      method: 'POST',
      headers: { 'api-key': DEEPAI_API_KEY },
      body
    });
    if (!res.ok) throw new Error(`DeepAI error: ${res.statusText}`);
    return await res.json();
  }

  async function generateImage(prompt) {
    appendMessage('user', prompt);
    appendMessage('bot', 'Generating image, please wait...');
    try {
      const data = await deepaiRequest('text2img', new URLSearchParams({ text: prompt }));
      if (data.output_url) {
        appendMessage('bot', `![Generated Image](${data.output_url})`);
        // Display inline image
        const img = document.createElement('img');
        img.src = data.output_url;
        img.style.maxWidth = '100%';
        chatContainer.appendChild(img);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      } else {
        appendMessage('bot', 'Failed to generate image.');
      }
    } catch (e) {
      appendMessage('bot', 'Error: ' + e.message);
    }
  }

  async function editImage(file) {
    if (!file || !file.type.startsWith('image/')) {
      alert('Please upload an image file to edit.');
      return;
    }
    appendMessage('user', 'Editing uploaded image...');
    appendMessage('bot', 'Processing image edit, please wait...');
    try {
      const formData = new FormData();
      formData.append('image', file);
      const data = await deepaiRequest('image-editor', formData);
      if (data.output_url) {
        appendMessage('bot', `![Edited Image](${data.output_url})`);
        const img = document.createElement('img');
        img.src = data.output_url;
        img.style.maxWidth = '100%';
        chatContainer.appendChild(img);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      } else {
        appendMessage('bot', 'Failed to edit image.');
      }
    } catch (e) {
      appendMessage('bot', 'Error: ' + e.message);
    }
  }

  async function analyzeFile(file) {
    if (!file) return;
    const type = file.type;
    if (type === 'application/pdf') {
      appendMessage('user', `Please analyze the PDF file: ${file.name}`);
      appendMessage('bot', 'Analyzing PDF file...');
      // No direct API for PDF content extraction in DeepAI free API, so just say not supported
      appendMessage('bot', 'Sorry, PDF content analysis is not supported via DeepAI API.');
    } else {
      appendMessage('user', `File analysis is currently supported only for PDFs.`);
      appendMessage('bot', 'Sorry, this feature is limited currently.');
    }
  }

  // ---- GPT-2 Local loading ----
  import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.5.0';

  async function loadGPT2(modelName) {
    appendMessage('bot', `Loading GPT-2 model: ${modelName} ...`);
    try {
      localGPT2Pipeline = await pipeline('text-generation', modelName);
      appendMessage('bot', `GPT-2 model loaded.`);
    } catch (e) {
      appendMessage('bot', 'Failed to load GPT-2 model.');
      console.error(e);
    }
  }

  // ---- Text generation ----
  async function generateText(prompt) {
    if (model.startsWith('gpt2')) {
      if (!localGPT2Pipeline) {
        await loadGPT2(model);
      }
      try {
        const output = await localGPT2Pipeline(prompt, {
          max_new_tokens: 100,
          temperature: 0.7,
          top_k: 50,
          top_p: 0.9,
          repetition_penalty: 1.2,
          stop: ['\n', '</s>'],
        });
        let reply = output[0].generated_text;
        reply = reply.replace(prompt, '').trim();
        if (!reply) reply = "Sorry, I didn't understand that. Could you rephrase?";
        return reply;
      } catch (e) {
        console.error('GPT-2 generation error:', e);
        return "Sorry, something went wrong with the AI.";
      }
    } else if (model === 'deepai-textgen') {
      // DeepAI text generation API call
      try {
        const res = await fetch('https://api.deepai.org/api/text-generator', {
          method: 'POST',
          headers: { 'api-key': DEEPAI_API_KEY, 'Accept': 'application/json' },
          body: new URLSearchParams({ text: prompt }),
        });
        const data = await res.json();
        if (data.output) {
          return data.output.trim();
        } else {
          return "Sorry, I couldn't generate a response.";
        }
      } catch (e) {
        console.error('DeepAI text gen error:', e);
        return "Error contacting DeepAI API.";
      }
    }
  }

  // ---- Personality filter ----
  function applyPersonalityFilter(text) {
    if (personality === 'roast') {
      // Simple roast responses: add a snarky remark occasionally
      const snarks = [
        "Hmm, really? That's what you came up with?",
        "Are you sure about that? Because I‚Äôm not impressed.",
        "I've heard better... but okay.",
        "Well, that‚Äôs kinda dumb, don‚Äôt you think?",
      ];
      if (Math.random() < 0.3) {
        text += ' ' + snarks[Math.floor(Math.random() * snarks.length)];
      }
    }
    // friendly just returns text
    return text;
  }

  // ---- Voice recognition and speech ----
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    recognition.onresult = e => {
      const transcript = e.results[0][0].transcript;
      userInput.value = transcript;
      stopListening();
      sendBtn.focus();
    };
    recognition.onerror = e => {
      console.error('Speech recognition error:', e.error);
      stopListening();
    };
    recognition.onend = () => {
      stopListening();
    };
  } else {
    voiceStartBtn.disabled = true;
    voiceStopBtn.disabled = true;
  }

  function startListening() {
    if (!recognition) return;
    listening = true;
    recognition.start();
    voiceStartBtn.disabled = true;
    voiceStopBtn.disabled = false;
  }
  function stopListening() {
    if (!recognition) return;
    listening = false;
    recognition.stop();
    voiceStartBtn.disabled = false;
    voiceStopBtn.disabled = true;
  }

  // Text to speech
  function speak(text) {
    if (!('speechSynthesis' in window)) return;
    const utter = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utter);
  }

  // ---- Chat send message handler ----
  async function sendMessage() {
    const txt = userInput.value.trim();
    if (!txt) return;
    appendMessage('user', txt);
    userInput.value = '';
    sendBtn.disabled = true;
    userInput.disabled = true;

    let reply = await generateText(txt);
    reply = applyPersonalityFilter(reply);
    appendMessage('bot', reply);
    speak(reply);

    sendBtn.disabled = false;
    userInput.disabled = false;
    userInput.focus();
  }

  // ---- UI Event bindings ----
  sendBtn.addEventListener('click', sendMessage);
  userInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendMessage();
    }
  });

  voiceStartBtn.addEventListener('click', () => {
    if (!listening) startListening();
  });
  voiceStopBtn.addEventListener('click', () => {
    if (listening) stopListening();
  });

  fileInput.addEventListener('change', () => {
    if (fileInput.files.length > 0) {
      handleFilePreview(fileInput.files[0]);
    } else {
      resetFilePreview();
    }
  });

  analyzeBtn.addEventListener('click', () => {
    if (fileInput.files.length > 0) analyzeFile(fileInput.files[0]);
  });

  editImageBtn.addEventListener('click', () => {
    if (fileInput.files.length > 0) editImage(fileInput.files[0]);
  });

  generateImageBtn.addEventListener('click', async () => {
    const prompt = promptUser('Enter a prompt for image generation:');
    if (prompt && prompt.trim().length > 0) {
      await generateImage(prompt.trim());
    }
  });

  personalitySelect.addEventListener('change', e => {
    personality = e.target.value;
    savePersonality();
  });

  modelSelect.addEventListener('change', e => {
    model = e.target.value;
    saveModel();
  });

  function promptUser(msg) {
    return window.prompt(msg);
  }

  // ---- Init ----

  function init() {
    loadChats();
    if (!activeChatId || !chats[activeChatId]) {
      // Create default chat if none exists
      const id = 'chat-' + Date.now();
      chats[id] = { name: 'New Chat', messages: [] };
      activeChatId = id;
      saveChats();
      saveActiveChat();
    }
    renderTabs();
    renderMessages();

    personality = localStorage.getItem(STORAGE_PERSONALITY_KEY) || 'friendly';
    model = localStorage.getItem(STORAGE_MODEL_KEY) || 'gpt2';

    personalitySelect.value = personality;
    modelSelect.value = model;

    // Preload GPT-2 small for better UX
    if (model.startsWith('gpt2')) {
      loadGPT2(model);
    }
  }

  init();

</script>
</body>
</html>
