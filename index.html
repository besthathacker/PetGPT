<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PetGPT Ultimate</title>
  <style>
    /* === Basic dark theme and layout === */
    body {
      margin: 0; padding: 0;
      font-family: Arial, sans-serif;
      background-color: #121212;
      color: #eee;
      height: 100vh;
      display: flex;
      overflow: hidden;
    }
    #sidebar {
      width: 280px;
      background: #222;
      display: flex;
      flex-direction: column;
    }
    #sidebar header {
      padding: 15px;
      font-size: 1.5em;
      background: #333;
      text-align: center;
      user-select: none;
    }
    #tabs {
      display: flex;
    }
    #tabs button {
      flex: 1;
      padding: 12px;
      background: #222;
      border: none;
      border-bottom: 2px solid transparent;
      color: #ccc;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s, border-color 0.3s;
    }
    #tabs button.active {
      background: #121212;
      border-bottom: 2px solid #4a90e2;
      color: white;
    }
    #content {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #1e1e1e;
    }
    #chatTab {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px 15px;
    }
    #chatMessages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      background: #2a2a2a;
      border-radius: 6px;
      margin-bottom: 10px;
      white-space: pre-wrap;
    }
    .message {
      margin-bottom: 10px;
      word-wrap: break-word;
    }
    .message.user {
      text-align: right;
      color: #9fdf9f;
    }
    .message.bot {
      text-align: left;
      color: #df9f9f;
    }
    #chatForm {
      display: flex;
    }
    #userInput {
      flex: 1;
      padding: 10px;
      border-radius: 6px 0 0 6px;
      border: none;
      font-size: 1em;
      outline: none;
    }
    #sendBtn {
      padding: 10px 15px;
      border: none;
      background-color: #4a90e2;
      color: white;
      font-weight: bold;
      border-radius: 0 6px 6px 0;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #sendBtn:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    #sendBtn:hover:not(:disabled) {
      background-color: #357ABD;
    }
    footer {
      padding: 8px 15px;
      text-align: center;
      background-color: #333;
      font-size: 0.9em;
      user-select: none;
    }
    /* Image generation tab */
    #imageGenTab {
      padding: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    #imagePrompt {
      width: 100%;
      max-width: 600px;
      padding: 10px;
      border-radius: 6px;
      border: none;
      font-size: 1em;
      outline: none;
    }
    #generateBtn {
      padding: 10px 25px;
      background-color: #4a90e2;
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
      user-select: none;
    }
    #generateBtn:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    #generateBtn:hover:not(:disabled) {
      background-color: #357ABD;
    }
    #generatedImage {
      max-width: 100%;
      max-height: 60vh;
      border-radius: 8px;
      margin-top: 10px;
      background: black;
      user-select: none;
    }
    /* File Upload tab */
    #fileUploadTab {
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #fileInput {
      user-select: none;
    }
    #filePreview {
      background: #2a2a2a;
      border-radius: 6px;
      padding: 10px;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      user-select: text;
    }
    #fileImagePreview {
      max-width: 100%;
      border-radius: 6px;
      user-select: none;
    }
    #sendFileToAI {
      padding: 10px 15px;
      background-color: #4a90e2;
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
      user-select: none;
    }
    #sendFileToAI:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    #sendFileToAI:hover:not(:disabled) {
      background-color: #357ABD;
    }
    #aiFileResponse {
      background: #2a2a2a;
      border-radius: 6px;
      padding: 10px;
      white-space: pre-wrap;
      max-height: 150px;
      overflow-y: auto;
      font-family: monospace;
      user-select: text;
    }

    /* Tabs container flex */
    #content > section {
      height: 100%;
    }
    /* Hide non-active tabs */
    [hidden] {
      display: none !important;
    }

    /* === Loading Overlay === */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(18, 18, 18, 0.95);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: #4a90e2;
      font-size: 1.3em;
      user-select: none;
    }
    #spinner {
      border: 8px solid #2a2a2a;
      border-top: 8px solid #4a90e2;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% {transform: rotate(0deg);}
      100% {transform: rotate(360deg);}
    }
  </style>
</head>
<body>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" aria-live="assertive" aria-busy="true" role="alert" aria-label="Loading models, please wait">
    <div id="spinner" role="img" aria-label="Loading spinner"></div>
    <div id="loadingText">Loading models, please wait...</div>
  </div>

  <!-- Sidebar with tabs -->
  <div id="sidebar" aria-label="Main sidebar">
    <header>PetGPT Ultimate</header>
    <div id="tabs" role="tablist">
      <button id="tabChat" class="active" role="tab" aria-selected="true" aria-controls="chatTab">Chat</button>
      <button id="tabImageGen" role="tab" aria-selected="false" aria-controls="imageGenTab">Image Gen</button>
      <button id="tabFileUpload" role="tab" aria-selected="false" aria-controls="fileUploadTab">File Upload</button>
    </div>
  </div>

  <!-- Content area -->
  <div id="content" role="main">
    <!-- Chat Tab -->
    <section id="chatTab" role="tabpanel" aria-labelledby="tabChat">
      <div id="chatMessages" aria-live="polite" aria-label="Chat messages"></div>
      <form id="chatForm" autocomplete="off">
        <input id="userInput" type="text" placeholder="Type your message..." required autocomplete="off" aria-label="Type your message"/>
        <button type="submit" id="sendBtn" disabled aria-label="Send message">Send</button>
      </form>
    </section>

    <!-- Image Generation Tab -->
    <section id="imageGenTab" role="tabpanel" aria-labelledby="tabImageGen" hidden>
      <input id="imagePrompt" type="text" placeholder="Enter image prompt..." autocomplete="off" aria-label="Image generation prompt" />
      <button id="generateBtn" disabled aria-label="Generate image">Generate Image</button>
      <img id="generatedImage" alt="Generated image will appear here" />
    </section>

    <!-- File Upload Tab -->
    <section id="fileUploadTab" role="tabpanel" aria-labelledby="tabFileUpload" hidden>
      <input id="fileInput" type="file" accept=".txt,.js,.py,.json,.html,.css,.md,.pdf,image/*,text/*" aria-label="Upload a file" />
      <div id="filePreview" hidden aria-live="polite" aria-label="File preview"></div>
      <img id="fileImagePreview" hidden alt="Image preview" />
      <button id="sendFileToAI" disabled aria-label="Send file content to AI for editing or explanation">Send to AI for editing/explanation</button>
      <pre id="aiFileResponse" hidden aria-live="polite" aria-label="AI response to file"></pre>
    </section>
  </div>

  <footer>Â© 2025 PetGPT Ultimate</footer>

<script type="module">
  import { pipeline } from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.3.0/dist/transformers.min.js";
  import { StableDiffusion } from "https://cdn.jsdelivr.net/npm/@xenova/diffusers@0.4.1/dist/diffusers.min.js";

  // Elements
  const loadingOverlay = document.getElementById('loadingOverlay');
  const loadingText = document.getElementById('loadingText');

  const chatMessages = document.getElementById('chatMessages');
  const chatForm = document.getElementById('chatForm');
  const userInput = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');

  const imagePrompt = document.getElementById('imagePrompt');
  const generateBtn = document.getElementById('generateBtn');
  const generatedImage = document.getElementById('generatedImage');

  const fileInput = document.getElementById('fileInput');
  const filePreview = document.getElementById('filePreview');
  const fileImagePreview = document.getElementById('fileImagePreview');
  const sendFileToAI = document.getElementById('sendFileToAI');
  const aiFileResponse = document.getElementById('aiFileResponse');

  const tabChat = document.getElementById('tabChat');
  const tabImageGen = document.getElementById('tabImageGen');
  const tabFileUpload = document.getElementById('tabFileUpload');

  const chatTab = document.getElementById('chatTab');
  const imageGenTab = document.getElementById('imageGenTab');
  const fileUploadTab = document.getElementById('fileUploadTab');

  let textGenerator;
  let stableDiffusion;

  // Append message helper
  function appendMessage(text, sender) {
    const msgDiv = document.createElement('div');
    msgDiv.classList.add('message', sender);
    msgDiv.textContent = text;
    chatMessages.appendChild(msgDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    return msgDiv;
  }

  // Tab switching function
  function switchTab(selectedTab) {
    if (selectedTab === 'chat') {
      tabChat.classList.add('active');
      tabChat.setAttribute('aria-selected', 'true');
      tabImageGen.classList.remove('active');
      tabImageGen.setAttribute('aria-selected', 'false');
      tabFileUpload.classList.remove('active');
      tabFileUpload.setAttribute('aria-selected', 'false');

      chatTab.hidden = false;
      imageGenTab.hidden = true;
      fileUploadTab.hidden = true;
    } else if (selectedTab === 'imageGen') {
      tabChat.classList.remove('active');
      tabChat.setAttribute('aria-selected', 'false');
      tabImageGen.classList.add('active');
      tabImageGen.setAttribute('aria-selected', 'true');
      tabFileUpload.classList.remove('active');
      tabFileUpload.setAttribute('aria-selected', 'false');

      chatTab.hidden = true;
      imageGenTab.hidden = false;
      fileUploadTab.hidden = true;
    } else {
      tabChat.classList.remove('active');
      tabChat.setAttribute('aria-selected', 'false');
      tabImageGen.classList.remove('active');
      tabImageGen.setAttribute('aria-selected', 'false');
      tabFileUpload.classList.add('active');
      tabFileUpload.setAttribute('aria-selected', 'true');

      chatTab.hidden = true;
      imageGenTab.hidden = true;
      fileUploadTab.hidden = false;
    }
  }
  tabChat.addEventListener('click', () => switchTab('chat'));
  tabImageGen.addEventListener('click', () => switchTab('imageGen'));
  tabFileUpload.addEventListener('click', () => switchTab('fileUpload'));

  // Enable send button when user types something
  userInput.addEventListener('input', () => {
    sendBtn.disabled = userInput.value.trim() === '';
  });

  // Chat form submit
  chatForm.addEventListener('submit', async e => {
    e.preventDefault();
    const userText = userInput.value.trim();
    if (!userText) return;

    appendMessage(userText, 'user');
    userInput.value = '';
    sendBtn.disabled = true;

    const typingMsg = appendMessage('...', 'bot');

    try {
      const output = await textGenerator(userText, { max_new_tokens: 50, do_sample: true, temperature: 0.7 });
      const reply = output[0]?.generated_text.slice(userText.length).trim() || "(No response)";
      typingMsg.textContent = reply;
    } catch (e) {
      typingMsg.textContent = "(Error generating response)";
      console.error(e);
    }

    sendBtn.disabled = false;
    userInput.focus();

    saveMemory();
  });

  // Enable generate image button on prompt input
  imagePrompt.addEventListener('input', () => {
    generateBtn.disabled = imagePrompt.value.trim() === '';
  });

  generateBtn.addEventListener('click', async () => {
    const prompt = imagePrompt.value.trim();
    if (!prompt) return;

    generateBtn.disabled = true;
    generateBtn.textContent = "Generating...";

    try {
      const imageTensor = await stableDiffusion.generate(prompt, {
        width: 512,
        height: 512,
        num_inference_steps: 20,
        guidance_scale: 7.5,
      });
      const blob = await imageTensor.toBlob();
      const url = URL.createObjectURL(blob);
      generatedImage.src = url;
      generatedImage.alt = `Generated image for prompt: ${prompt}`;
    } catch (e) {
      alert("Error generating image: " + e.message);
      generatedImage.src = "";
      generatedImage.alt = "No image generated";
    }

    generateBtn.textContent = "Generate Image";
    generateBtn.disabled = imagePrompt.value.trim() === '';
  });

  // File upload processing
  fileInput.addEventListener('change', async () => {
    aiFileResponse.hidden = true;
    sendFileToAI.disabled = true;
    filePreview.hidden = true;
    fileImagePreview.hidden = true;
    filePreview.textContent = '';
    fileImagePreview.src = '';

    const file = fileInput.files[0];
    if (!file) return;

    const fileType = file.type;

    if (fileType.startsWith('image/')) {
      // Show image preview
      const imgURL = URL.createObjectURL(file);
      fileImagePreview.src = imgURL;
      fileImagePreview.hidden = false;
      sendFileToAI.disabled = false;
      filePreview.hidden = true;
    } else if (fileType === 'application/pdf') {
      // Load PDF text with pdf.js
      try {
        await loadPDFjs();
        const pdfText = await extractTextFromPDF(file);
        filePreview.textContent = pdfText || '(No extractable text found)';
        filePreview.hidden = false;
        fileImagePreview.hidden = true;
        sendFileToAI.disabled = false;
      } catch (e) {
        filePreview.textContent = "(Failed to extract PDF text: " + e.message + ")";
        filePreview.hidden = false;
        fileImagePreview.hidden = true;
        sendFileToAI.disabled = true;
      }
    } else if (fileType.startsWith('text/') || isCodeFile(file.name)) {
      const text = await file.text();
      filePreview.contentEditable = true;
      filePreview.textContent = text;
      filePreview.hidden = false;
      fileImagePreview.hidden = true;
      sendFileToAI.disabled = false;
    } else {
      filePreview.textContent = "(Unsupported file type)";
      filePreview.hidden = false;
      fileImagePreview.hidden = true;
      sendFileToAI.disabled = true;
    }
  });

  // Check if filename looks like code file
  function isCodeFile(filename) {
    return /\.(js|py|json|html|css|md|txt)$/i.test(filename);
  }

  // PDF.js loading and text extraction helpers
  let pdfjsLib;
  async function loadPDFjs() {
    if (pdfjsLib) return;
    pdfjsLib = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js');
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';
  }
  async function extractTextFromPDF(file) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
    let text = '';
    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const content = await page.getTextContent();
      for (const item of content.items) {
        text += item.str + ' ';
      }
      text += '\n\n';
    }
    return text.trim();
  }

  // Send file content to AI button
  sendFileToAI.addEventListener('click', async () => {
    sendFileToAI.disabled = true;
    aiFileResponse.hidden = true;
    aiFileResponse.textContent = '';

    let prompt = '';
    if (!fileInput.files[0]) {
      alert("No file loaded.");
      sendFileToAI.disabled = false;
      return;
    }

    const file = fileInput.files[0];
    if (file.type.startsWith('image/')) {
      alert("Image editing via AI is not yet implemented here.");
      sendFileToAI.disabled = false;
      return;
    } else {
      // For text/code/pdf extract: send the preview content as prompt for explanation/editing
      prompt = filePreview.textContent.trim();
      if (!prompt) {
        alert("File preview is empty.");
        sendFileToAI.disabled = false;
        return;
      }
    }

    appendMessage("File content sent for AI analysis...", "user");

    try {
      const output = await textGenerator(prompt, { max_new_tokens: 150, do_sample: true, temperature: 0.7 });
      const reply = output[0]?.generated_text.slice(prompt.length).trim() || "(No response)";
      aiFileResponse.textContent = reply;
      aiFileResponse.hidden = false;
      appendMessage(reply, "bot");
    } catch (e) {
      aiFileResponse.textContent = "(Error generating response)";
      aiFileResponse.hidden = false;
      console.error(e);
    }

    sendFileToAI.disabled = false;
  });

  // LocalStorage chat memory
  const MEMORY_KEY = 'petgpt_chat_memory';
  function loadMemory() {
    const data = localStorage.getItem(MEMORY_KEY);
    if (data) {
      try {
        const messages = JSON.parse(data);
        messages.forEach(({ text, sender }) => {
          appendMessage(text, sender);
        });
      } catch {
        localStorage.removeItem(MEMORY_KEY);
      }
    }
  }
  function saveMemory() {
    const messages = [];
    document.querySelectorAll('#chatMessages .message').forEach(msg => {
      messages.push({
        text: msg.textContent,
        sender: msg.classList.contains('user') ? 'user' : 'bot'
      });
    });
    localStorage.setItem(MEMORY_KEY, JSON.stringify(messages));
  }

  // Initialize models with loading overlay
  async function initModels() {
    loadingText.textContent = "Loading GPT-2 model... Please wait.";
    try {
      textGenerator = await pipeline("text-generation", "Xenova/gpt-2");
      loadingText.textContent = "Loading Stable Diffusion model... Please wait.";
      stableDiffusion = await StableDiffusion.create();
      loadingText.textContent = "All models loaded. Enjoy!";
      await new Promise(r => setTimeout(r, 800));
    } catch (e) {
      loadingText.textContent = "Failed to load models. See console.";
      console.error(e);
      alert("Error loading models. Check console for details.");
    }
    loadingOverlay.style.display = "none";

    // Enable buttons after load
    sendBtn.disabled = userInput.value.trim() === '';
    generateBtn.disabled = imagePrompt.value.trim() === '';
  }

  // On window load
  window.onload = () => {
    loadMemory();
    initModels();
  };
</script>

</body>
</html>
