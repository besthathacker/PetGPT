<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PetGPT Ultimate</title>

<!-- PWA Manifest & Icon -->
<link rel="manifest" href="manifest.json" />
<link rel="icon" href="petgpt-icon-512.png" type="image/png" />
<meta name="theme-color" content="#000000" />

<style>
  /* Reset & base */
  * { box-sizing: border-box; }
  body, html {
    margin: 0; padding: 0; height: 100vh; font-family: Arial, sans-serif;
    background: #121212; color: #eee; display: flex; overflow: hidden;
  }
  /* Layout */
  #sidebar {
    width: 280px; background: #1f1f1f; border-right: 2px solid #444;
    display: flex; flex-direction: column; padding: 10px;
  }
  #sidebar h2 {
    margin: 0 0 10px 0; text-align: center; color: #68a;
  }
  #chatList {
    flex-grow: 1; overflow-y: auto; border: 1px solid #333; background: #222;
    padding: 5px; border-radius: 6px;
  }
  #chatList div.chat-item {
    background: #2a2a2a; margin-bottom: 6px; padding: 8px 6px; border-radius: 4px;
    cursor: pointer; display: flex; align-items: center; justify-content: space-between;
    color: #ccc;
  }
  #chatList div.chat-item.active {
    background: #4466aa;
    color: white;
  }
  #chatList div.chat-item input {
    flex-grow: 1; background: transparent; border: none; color: white;
    font-size: 1rem; outline: none;
  }
  #chatControls {
    margin-top: 10px; display: flex; gap: 6px;
  }
  #chatControls button {
    flex-grow: 1; padding: 8px; border: none; background: #357; color: white;
    cursor: pointer; border-radius: 4px;
  }
  #chatControls button:disabled {
    background: #555; cursor: not-allowed;
  }
  /* Main chat area */
  #main {
    flex-grow: 1; display: flex; flex-direction: column; background: #1e1e1e;
  }
  #chatHeader {
    padding: 12px; background: #222; border-bottom: 1px solid #444;
    display: flex; justify-content: space-between; align-items: center;
  }
  #chatTitle {
    font-size: 1.3rem; color: #aaf;
    flex-grow: 1; user-select: none;
  }
  #renameChatBtn, #deleteChatBtn {
    background: #4488cc; border: none; color: white; padding: 6px 12px;
    margin-left: 6px; border-radius: 4px; cursor: pointer;
  }
  #renameChatBtn:disabled, #deleteChatBtn:disabled {
    background: #555; cursor: not-allowed;
  }
  #chatArea {
    flex-grow: 1; overflow-y: auto; padding: 10px;
    display: flex; flex-direction: column; gap: 8px;
    background: #111;
  }
  .message {
    max-width: 70%; padding: 10px 14px; border-radius: 8px;
    word-wrap: break-word; white-space: pre-wrap;
  }
  .message.user {
    background: #2b4; align-self: flex-end; color: #010;
  }
  .message.bot {
    background: #3466bb; align-self: flex-start; color: white;
  }
  /* Input area */
  #inputArea {
    display: flex; padding: 10px; background: #222; border-top: 1px solid #444;
    gap: 6px; align-items: center;
  }
  #userInput {
    flex-grow: 1; padding: 8px 12px; border-radius: 6px; border: none;
    font-size: 1rem; background: #333; color: white;
  }
  #userInput::placeholder {
    color: #aaa;
  }
  button#sendBtn, button#voiceBtn, button#uploadBtn, button#imgGenBtn {
    background: #357; border: none; color: white;
    padding: 8px 12px; border-radius: 6px; cursor: pointer;
    user-select: none;
  }
  button:disabled {
    background: #555; cursor: not-allowed;
  }
  /* File input hidden */
  #fileInput {
    display: none;
  }
  /* Personality selector */
  #personalitySelect {
    margin-left: 8px; background: #333; color: white; border: none; border-radius: 4px;
    padding: 6px;
    font-size: 1rem;
    user-select: none;
  }
  /* Filters */
  #filterArea {
    margin-top: 4px; padding: 6px 10px; background: #222; color: #ccc;
    font-size: 0.9rem; border-top: 1px solid #444;
  }
  /* Image modal */
  #imageModal {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1000; padding: 10px;
  }
  #imageModal.visible {
    display: flex;
  }
  #imageModalContent {
    background: #222; padding: 12px; border-radius: 8px; max-width: 90vw; max-height: 80vh;
    display: flex; flex-direction: column; align-items: center;
  }
  #imagePreview {
    max-width: 100%; max-height: 60vh; border-radius: 6px; margin-bottom: 12px;
    background: black;
  }
  #imagePrompt {
    width: 100%; padding: 8px; border-radius: 6px; border: none; font-size: 1rem;
    margin-bottom: 8px; background: #333; color: white;
  }
  #imageControls {
    display: flex; gap: 10px; width: 100%; justify-content: space-between;
    flex-wrap: wrap;
  }
  #imageControls > * {
    flex-grow: 1;
    min-width: 120px;
  }
  label {
    font-size: 0.85rem;
    display: flex; flex-direction: column; gap: 4px; color: #ccc;
  }
  input[type=range] {
    width: 100%;
  }
  #generateImageBtn, #closeImageModalBtn {
    padding: 8px 12px; border-radius: 6px; border: none;
    cursor: pointer; background: #357; color: white;
    user-select: none;
  }
  /* Virtual Pet */
  #petAvatar {
    position: fixed; bottom: 20px; right: 20px;
    width: 120px; height: 120px;
    background: url('petgpt-icon-512.png') no-repeat center/contain;
    border-radius: 50%; box-shadow: 0 0 10px #4466aaaa;
    cursor: pointer;
    transition: transform 0.3s ease;
    user-select: none;
  }
  #petAvatar:hover {
    transform: scale(1.1);
  }
</style>

</head>
<body>

<div id="sidebar" role="navigation" aria-label="Chat list and controls">
  <h2>PetGPT Chats</h2>
  <div id="chatList" role="listbox" tabindex="0" aria-label="Chats list"></div>
  <div id="chatControls">
    <button id="newChatBtn" aria-label="Create new chat">+ New Chat</button>
    <button id="clearMemoryBtn" aria-label="Clear all chat memory">Clear Memory</button>
  </div>
  <div id="filterArea" aria-label="Chat filters and options">
    Filter: <input type="text" id="chatFilterInput" placeholder="Search chats or messages" aria-label="Chat search filter" />
    <select id="personalitySelect" aria-label="Personality selection">
      <option value="friendly">Friendly</option>
      <option value="roast">Roast (on request)</option>
      <option value="formal">Formal</option>
    </select>
  </div>
</div>

<div id="main" role="main">
  <div id="chatHeader" aria-live="polite">
    <div id="chatTitle" contenteditable="true" role="textbox" aria-label="Chat title" spellcheck="false">New Chat</div>
    <button id="renameChatBtn" aria-label="Rename chat">Rename</button>
    <button id="deleteChatBtn" aria-label="Delete chat">Delete</button>
  </div>

  <div id="chatArea" aria-live="polite" aria-relevant="additions" role="log"></div>

  <div id="inputArea">
    <input type="text" id="userInput" aria-label="Message input" placeholder="Type your message..." autocomplete="off" />
    <button id="sendBtn" aria-label="Send message">Send</button>
    <button id="voiceBtn" aria-label="Start voice input">üé§</button>
    <button id="uploadBtn" aria-label="Upload file">üìé</button>
    <button id="imgGenBtn" aria-label="Generate or edit image">üñºÔ∏è</button>
    <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.gif,.bmp,.pdf,.txt,.js,.py,.json,.html,.css,.cpp,.java,.c,.ts,.md" aria-hidden="true" />
  </div>
</div>

<!-- Image generation & editing modal -->
<div id="imageModal" role="dialog" aria-modal="true" aria-labelledby="imageModalTitle">
  <div id="imageModalContent">
    <h3 id="imageModalTitle" style="color:white;">Image Generation & Editing</h3>
    <img id="imagePreview" alt="Image preview" />
    <textarea id="imagePrompt" placeholder="Enter prompt or instructions here..." rows="3"></textarea>
    <div id="imageControls">
      <label>Width: <input type="range" id="imgWidth" min="256" max="768" step="64" value="512" /></label>
      <label>Height: <input type="range" id="imgHeight" min="256" max="768" step="64" value="512" /></label>
      <label>Steps: <input type="range" id="imgSteps" min="5" max="50" step="1" value="25" /></label>
      <label>Guidance Scale: <input type="range" id="imgGuidance" min="1" max="20" step="0.5" value="7.5" /></label>
    </div>
    <button id="generateImageBtn">Generate/Edit</button>
    <button id="closeImageModalBtn" style="margin-top:8px;background:#aa3333;">Close</button>
  </div>
</div>

<!-- Virtual Pet Avatar -->
<div id="petAvatar" title="Your virtual pet, Cheeto üê±"></div>

<script type="module">
import { pipeline } from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.3.0/dist/transformers.min.js";
import { StableDiffusion } from "https://cdn.jsdelivr.net/npm/@xenova/diffusers@0.3.0/dist/diffusers.min.js";

window.addEventListener('DOMContentLoaded', () => {
  (async () => {
    // --- GPT-2 Pipeline ---
    let textPipeline;
    try {
      textPipeline = await pipeline('text-generation', 'Xenova/gpt2');
      console.log('GPT-2 loaded');
    } catch (e) {
      alert('Failed to load GPT-2 model: ' + e.message);
      console.error(e);
      return;
    }

    // --- Stable Diffusion ---
    let sdModel;
    try {
      sdModel = await StableDiffusion.create();
      console.log('Stable Diffusion loaded');
    } catch (e) {
      alert('Failed to load Stable Diffusion: ' + e.message);
      console.error(e);
      // No return, user can still chat
    }

    // DOM Elements
    const chatListEl = document.getElementById('chatList');
    const newChatBtn = document.getElementById('newChatBtn');
    const clearMemoryBtn = document.getElementById('clearMemoryBtn');
    const chatFilterInput = document.getElementById('chatFilterInput');
    const personalitySelect = document.getElementById('personalitySelect');

    const chatTitle = document.getElementById('chatTitle');
    const renameChatBtn = document.getElementById('renameChatBtn');
    const deleteChatBtn = document.getElementById('deleteChatBtn');
    const chatArea = document.getElementById('chatArea');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const voiceBtn = document.getElementById('voiceBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');

    const imgGenBtn = document.getElementById('imgGenBtn');
    const imageModal = document.getElementById('imageModal');
    const closeImageModalBtn = document.getElementById('closeImageModalBtn');
    const generateImageBtn = document.getElementById('generateImageBtn');
    const imagePreview = document.getElementById('imagePreview');
    const imagePrompt = document.getElementById('imagePrompt');
    const imgWidth = document.getElementById('imgWidth');
    const imgHeight = document.getElementById('imgHeight');
    const imgSteps = document.getElementById('imgSteps');
    const imgGuidance = document.getElementById('imgGuidance');

    const renameModeDuration = 3000;

    // Virtual pet avatar
    const petAvatar = document.getElementById('petAvatar');

    // Data structure for chats
    let chats = [];
    let activeChatId = null;

    // Load chats from localStorage
    function loadChats() {
      const stored = localStorage.getItem('petgpt_chats');
      if (stored) {
        chats = JSON.parse(stored);
      } else {
        chats = [];
      }
    }

    // Save chats to localStorage
    function saveChats() {
      localStorage.setItem('petgpt_chats', JSON.stringify(chats));
    }

    // Create a new chat with unique id and empty messages
    function createNewChat(title = 'New Chat') {
      const id = Date.now().toString();
      chats.push({ id, title, messages: [] });
      saveChats();
      setActiveChat(id);
      renderChatList();
    }

    // Set active chat by id
    function setActiveChat(id) {
      activeChatId = id;
      renderChatList();
      renderActiveChat();
    }

    // Delete chat by id
    function deleteChat(id) {
      chats = chats.filter(c => c.id !== id);
      if (activeChatId === id) {
        activeChatId = chats.length ? chats[0].id : null;
      }
      saveChats();
      renderChatList();
      renderActiveChat();
    }

    // Rename active chat
    function renameActiveChat(newTitle) {
      if (!activeChatId) return;
      const chat = chats.find(c => c.id === activeChatId);
      if (chat) {
        chat.title = newTitle || 'Untitled Chat';
        saveChats();
        renderChatList();
        renderActiveChat();
      }
    }

    // Clear all memory (chats)
    function clearAllMemory() {
      if (!confirm('Are you sure you want to clear all chat memory?')) return;
      chats = [];
      activeChatId = null;
      saveChats();
      renderChatList();
      renderActiveChat();
    }

    // Render chat list in sidebar
    function renderChatList(filter = '') {
      chatListEl.innerHTML = '';
      const filteredChats = chats.filter(c =>
        c.title.toLowerCase().includes(filter.toLowerCase()) ||
        c.messages.some(m => m.text.toLowerCase().includes(filter.toLowerCase()))
      );

      filteredChats.forEach(chat => {
        const div = document.createElement('div');
        div.className = 'chat-item' + (chat.id === activeChatId ? ' active' : '');
        div.setAttribute('role', 'option');
        div.tabIndex = 0;

        // Editable title input for rename inline
        const input = document.createElement('input');
        input.type = 'text';
        input.value = chat.title;
        input.spellcheck = false;
        input.style.display = 'none';

        // Show title span by default
        const span = document.createElement('span');
        span.textContent = chat.title;

        div.appendChild(span);
        div.appendChild(input);

        div.addEventListener('click', () => setActiveChat(chat.id));

        // Inline rename on double-click
        span.addEventListener('dblclick', () => {
          span.style.display = 'none';
          input.style.display = 'block';
          input.focus();
          input.selectionStart = input.value.length;
        });

        // Rename on input blur or enter
        input.addEventListener('blur', () => {
          const newTitle = input.value.trim() || 'Untitled Chat';
          renameActiveChat(newTitle);
          span.style.display = 'block';
          input.style.display = 'none';
        });
        input.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            input.blur();
          }
        });

        chatListEl.appendChild(div);
      });
    }

    // Render active chat messages
    function renderActiveChat() {
      chatArea.innerHTML = '';
      if (!activeChatId) {
        chatTitle.textContent = 'No Chat Selected';
        renameChatBtn.disabled = true;
        deleteChatBtn.disabled = true;
        sendBtn.disabled = true;
        userInput.disabled = true;
        return;
      }
      renameChatBtn.disabled = false;
      deleteChatBtn.disabled = false;
      sendBtn.disabled = false;
      userInput.disabled = false;

      const chat = chats.find(c => c.id === activeChatId);
      chatTitle.textContent = chat.title;

      chat.messages.forEach(msg => {
        const div = document.createElement('div');
        div.className = 'message ' + (msg.from === 'user' ? 'user' : 'bot');
        div.textContent = msg.text;
        chatArea.appendChild(div);
      });

      chatArea.scrollTop = chatArea.scrollHeight;
      userInput.focus();
    }

    // Add message to active chat
    function addMessageToActiveChat(from, text) {
      if (!activeChatId) return;
      const chat = chats.find(c => c.id === activeChatId);
      chat.messages.push({ from, text });
      saveChats();
      renderActiveChat();
    }

    // Send user input to GPT-2 and get response
    async function sendUserMessage() {
      const message = userInput.value.trim();
      if (!message) return;

      addMessageToActiveChat('user', message);

      userInput.value = '';
      sendBtn.disabled = true;
      userInput.disabled = true;

      try {
        let personality = personalitySelect.value;

        // For "roast" personality, prepend a roast prompt if requested
        let prompt = message;
        if (personality === 'roast') {
          prompt = "Roast the user politely:\nUser: " + message + "\nAI:";
        } else if (personality === 'formal') {
          prompt = "Respond formally:\nUser: " + message + "\nAI:";
        }
        // Else friendly (default), prompt is the raw message

        const output = await textPipeline(prompt, { max_new_tokens: 100, do_sample: true });
        let reply = output[0].generated_text;

        // Remove the prompt part from reply if included
        reply = reply.replace(prompt, '').trim();

        if (!reply) reply = "Sorry, I couldn't generate a response.";

        addMessageToActiveChat('bot', reply);

      } catch (e) {
        console.error('GPT-2 generation error:', e);
        addMessageToActiveChat('bot', 'Error generating response.');
      } finally {
        sendBtn.disabled = false;
        userInput.disabled = false;
        userInput.focus();
      }
    }

    // Handle Enter key in input
    userInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendUserMessage();
      }
    });

    sendBtn.addEventListener('click', sendUserMessage);

    // New Chat button
    newChatBtn.addEventListener('click', () => {
      createNewChat();
    });

    // Clear memory button
    clearMemoryBtn.addEventListener('click', () => {
      clearAllMemory();
    });

    // Rename Chat button (commits current chatTitle contenteditable text)
    renameChatBtn.addEventListener('click', () => {
      const newTitle = chatTitle.textContent.trim();
      if (!newTitle) {
        alert('Chat title cannot be empty.');
        chatTitle.textContent = chats.find(c => c.id === activeChatId)?.title || 'New Chat';
        return;
      }
      renameActiveChat(newTitle);
    });

    // Delete Chat button
    deleteChatBtn.addEventListener('click', () => {
      if (!activeChatId) return;
      if (confirm('Delete this chat? This action cannot be undone.')) {
        deleteChat(activeChatId);
      }
    });

    // Filter chats on typing
    chatFilterInput.addEventListener('input', () => {
      renderChatList(chatFilterInput.value);
    });

    // Personality change does nothing immediate, just used on next send

    // Chat list keyboard navigation: select on Enter or Space
    chatListEl.addEventListener('keydown', e => {
      if (e.target.classList.contains('chat-item')) {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const idx = Array.from(chatListEl.children).indexOf(e.target);
          if (idx !== -1) {
            const chat = chats[idx];
            setActiveChat(chat.id);
          }
        }
      }
    });

    // File upload handling
    uploadBtn.addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const fileName = file.name.toLowerCase();
      const ext = fileName.split('.').pop();

      if (['png', 'jpg', 'jpeg', 'gif', 'bmp'].includes(ext)) {
        // Show image in modal and allow editing
        const url = URL.createObjectURL(file);
        imagePreview.src = url;
        imagePrompt.value = '';
        showImageModal();
      } else if (ext === 'pdf') {
        // For PDFs, just say "PDF files not supported yet" (can be extended)
        alert('PDF preview/editing not supported yet.');
      } else {
        // For code/text files, read as text and add to chat as user message
        const text = await file.text();
        addMessageToActiveChat('user', `Uploaded file (${file.name}):\n${text}`);
      }

      fileInput.value = ''; // Reset input
    });

    // Image modal controls
    function showImageModal() {
      imageModal.classList.add('visible');
    }
    function hideImageModal() {
      imageModal.classList.remove('visible');
      imagePreview.src = '';
      imagePrompt.value = '';
    }
    closeImageModalBtn.addEventListener('click', () => {
      hideImageModal();
    });

    imgGenBtn.addEventListener('click', () => {
      showImageModal();
    });

    generateImageBtn.addEventListener('click', async () => {
      if (!sdModel) {
        alert('Stable Diffusion model not loaded.');
        return;
      }
      generateImageBtn.disabled = true;

      const promptText = imagePrompt.value.trim();
      if (!promptText) {
        alert('Please enter a prompt or instructions.');
        generateImageBtn.disabled = false;
        return;
      }

      try {
        generateImageBtn.textContent = 'Generating...';
        const width = parseInt(imgWidth.value);
        const height = parseInt(imgHeight.value);
        const steps = parseInt(imgSteps.value);
        const guidance = parseFloat(imgGuidance.value);

        const img = await sdModel.textToImage(promptText, {
          width,
          height,
          numInferenceSteps: steps,
          guidanceScale: guidance,
        });

        imagePreview.src = img.src;

      } catch (e) {
        console.error('Image generation error:', e);
        alert('Failed to generate image.');
      } finally {
        generateImageBtn.textContent = 'Generate/Edit';
        generateImageBtn.disabled = false;
      }
    });

    // Virtual pet avatar click: playful scale animation
    petAvatar.addEventListener('click', () => {
      petAvatar.style.transform = 'scale(1.3)';
      setTimeout(() => petAvatar.style.transform = 'scale(1)', 300);
    });

    // Initialize app: load chats, create first chat if none
    loadChats();
    if (chats.length === 0) {
      createNewChat('Welcome Chat');
    } else {
      setActiveChat(chats[0].id);
    }
    renderChatList();
  })();
});
</script>

</body>
</html>
