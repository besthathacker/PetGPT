<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PetGPT Ultimate</title>
<style>
  /* Reset & basic styles */
  * {
    box-sizing: border-box;
  }
  body {
    font-family: Arial, sans-serif;
    margin: 0; padding: 0;
    background: #1e1e1e;
    color: #eee;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header, footer {
    background: #007acc;
    color: white;
    text-align: center;
    padding: 1rem;
    user-select: none;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
    max-width: 700px;
    margin: 0 auto;
    width: 100%;
    padding: 0 1rem 1rem;
    overflow: hidden;
  }
  #chat {
    flex: 1;
    background: #2b2b2b;
    border-radius: 8px;
    padding: 10px;
    overflow-y: auto;
    margin-bottom: 10px;
    font-size: 1rem;
  }
  .message {
    max-width: 75%;
    margin: 6px 0;
    padding: 8px;
    border-radius: 6px;
    word-wrap: break-word;
  }
  .user {
    background: #3a3a3a;
    align-self: flex-end;
  }
  .bot {
    background: #007acc;
    align-self: flex-start;
  }
  #controls {
    display: flex;
    gap: 8px;
  }
  #userInput {
    flex: 1;
    padding: 10px;
    border-radius: 6px;
    border: none;
    background: #333;
    color: #eee;
    font-size: 1rem;
  }
  #userInput:focus {
    outline: 2px solid #007acc;
  }
  button {
    padding: 10px 14px;
    background: #007acc;
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    user-select: none;
    font-size: 1rem;
    transition: background 0.2s ease;
  }
  button:disabled {
    background: #444;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background: #005f99;
  }
  #adminPanel {
    display: none;
    background: #333;
    padding: 10px;
    margin-top: 1rem;
    border-radius: 8px;
    color: #eee;
  }
  #adminPanel h4 {
    margin-top: 0;
  }
  #bgPicker {
    margin-left: 0.5rem;
    vertical-align: middle;
  }
  /* File Upload Section */
  #fileSection {
    margin-top: 1rem;
    background: #222;
    padding: 10px;
    border-radius: 8px;
    color: #ccc;
    font-size: 0.9rem;
  }
  #fileHexPreview {
    margin-top: 0.5rem;
    background: #111;
    color: #0f0;
    font-family: monospace;
    font-size: 0.75rem;
    height: 150px;
    overflow-y: auto;
    padding: 10px;
    border-radius: 6px;
    white-space: pre-wrap;
  }
  /* Dark mode toggle */
  #darkModeToggle {
    margin-left: auto;
    background: #444;
    font-size: 0.9rem;
  }
  /* Responsive */
  @media (max-width: 600px) {
    #chat {
      font-size: 0.9rem;
    }
    button, #userInput {
      font-size: 0.9rem;
    }
  }
</style>
</head>
<body>
<header>PetGPT Ultimate</header>
<main>
  <div id="chat" role="log" aria-live="polite" aria-atomic="false"></div>
  <div id="controls">
    <input id="userInput" placeholder="Type your message..." autocomplete="off" aria-label="Type your message" />
    <button id="sendBtn" aria-label="Send message">Send</button>
    <button id="resetBtn" aria-label="Reset memory">Reset Memory</button>
    <button id="voiceBtn" aria-label="Toggle voice chat">🎤 Voice Chat</button>
    <button id="adminToggleBtn" aria-label="Toggle admin panel">⚙️</button>
    <button id="darkModeToggle" aria-label="Toggle dark/light mode">Light Mode</button>
  </div>

  <div id="adminPanel" aria-hidden="true">
    <h4>Admin Panel (type "cheeto" to toggle)</h4>
    <label>Background Color: <input type="color" id="bgPicker" aria-label="Pick background color" /></label>
  </div>

  <section id="fileSection" aria-label="File upload and preview">
    <label for="fileInput">Upload any file:</label>
    <input type="file" id="fileInput" aria-describedby="fileHelp" />
    <div id="fileHelp">Shows hex preview for binary files.</div>
    <pre id="fileHexPreview" aria-live="polite" aria-atomic="true"></pre>
  </section>
</main>
<footer>© 2025 PetGPT Ultimate</footer>

<script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.5.0/dist/transformers.min.js"></script>
<script>
(async () => {
  // UI refs
  const chat = document.getElementById('chat');
  const userInput = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');
  const resetBtn = document.getElementById('resetBtn');
  const voiceBtn = document.getElementById('voiceBtn');
  const adminPanel = document.getElementById('adminPanel');
  const adminToggleBtn = document.getElementById('adminToggleBtn');
  const bgPicker = document.getElementById('bgPicker');
  const darkModeToggle = document.getElementById('darkModeToggle');
  const fileInput = document.getElementById('fileInput');
  const fileHexPreview = document.getElementById('fileHexPreview');

  // State
  let gptReady = false;
  let tokenizer, model;
  let memory = JSON.parse(localStorage.getItem('petgpt-memory') || '{}');
  let recognizing = false;
  let recognition;

  // Dark mode default state
  let darkMode = true;
  function updateDarkModeUI() {
    if (darkMode) {
      document.body.style.background = '#1e1e1e';
      darkModeToggle.textContent = 'Light Mode';
      document.body.style.color = '#eee';
    } else {
      document.body.style.background = '#eee';
      darkModeToggle.textContent = 'Dark Mode';
      document.body.style.color = '#111';
    }
  }
  updateDarkModeUI();

  // Append chat message
  function append(msg, cls) {
    const d = document.createElement('div');
    d.className = 'message ' + cls;
    d.textContent = msg;
    chat.appendChild(d);
    chat.scrollTop = chat.scrollHeight;
  }

  // Save memory to localStorage
  function saveMem() {
    localStorage.setItem('petgpt-memory', JSON.stringify(memory));
  }

  // Simple fallback dictionary
  const fallbackModel = {
    hello: "Hi there! How can I help you today?",
    bye: "Goodbye! Have a great day!",
    'how are you': "I'm just a bunch of code, but thanks for asking!",
  };

  // Chat reply logic
  async function getReply(text) {
    const t = text.toLowerCase();

    if (t.startsWith('remember:')) {
      const [k, v] = t.slice(9).split('=').map(s => s.trim());
      if (k && v) {
        memory[k] = v;
        saveMem();
        return `Got it! I'll remember ${k} = ${v}`;
      }
      return 'Use: remember:key=value';
    }

    for (const k in memory) {
      if (t.includes(k.toLowerCase())) {
        return `You told me ${k} = ${memory[k]}`;
      }
    }

    if (t.includes('cheeto')) {
      toggleAdmin(true);
      return 'Admin unlocked!';
    }

    // Use GPT-2 if ready
    if (gptReady && model && tokenizer) {
      try {
        const encoded = await tokenizer.encode(text);
        const output = await model.generate(encoded.inputIds, {
          max_new_tokens: 50,
          do_sample: true,
          temperature: 0.7,
          top_p: 0.9,
        });
        const decoded = await tokenizer.decode(output[0]);
        let reply = decoded.replace(text, '').trim();
        if (!reply) reply = "Hmm, I don't know what to say.";
        return reply;
      } catch (e) {
        console.error('GPT-2 generation error:', e);
        return "Sorry, I had trouble thinking...";
      }
    }

    // Fallback dictionary matching
    for (const key in fallbackModel) {
      if (t.includes(key)) return fallbackModel[key];
    }
    return "Sorry, I don't understand.";
  }

  // Send message handler
  async function sendMessage() {
    const txt = userInput.value.trim();
    if (!txt) return;
    append('You: ' + txt, 'user');
    userInput.value = '';
    userInput.disabled = true;
    sendBtn.disabled = true;
    try {
      const reply = await getReply(txt);
      append('PetGPT: ' + reply, 'bot');
    } catch (e) {
      append('PetGPT: Sorry, an error occurred.', 'bot');
      console.error(e);
    } finally {
      userInput.disabled = false;
      sendBtn.disabled = false;
      userInput.focus();
    }
  }
  sendBtn.onclick = sendMessage;
  userInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendMessage();
    }
  });

  // Reset memory and chat
  resetBtn.onclick = () => {
    if (confirm('Clear memory and chat?')) {
      localStorage.clear();
      memory = {};
      chat.innerHTML = '';
      append('Memory cleared.', 'bot');
    }
  };

  // Admin panel toggle (button & automatic)
  function toggleAdmin(show) {
    if (typeof show === 'boolean') {
      adminPanel.style.display = show ? 'block' : 'none';
      adminPanel.setAttribute('aria-hidden', !show);
    } else {
      const isVisible = adminPanel.style.display === 'block';
      adminPanel.style.display = isVisible ? 'none' : 'block';
      adminPanel.setAttribute('aria-hidden', isVisible);
    }
  }
  adminToggleBtn.onclick = () => toggleAdmin();

  // Background color picker
  bgPicker.oninput = e => document.body.style.background = e.target.value;

  // Dark mode toggle button
  darkModeToggle.onclick = () => {
    darkMode = !darkMode;
    updateDarkModeUI();
  };

  // Voice recognition
  if (window.SpeechRecognition || window.webkitSpeechRecognition) {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SR();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.continuous = false;
    recognition.onstart = () => {
      recognizing = true;
      voiceBtn.textContent = '🛑 Stop';
    };
    recognition.onend = () => {
      recognizing = false;
      voiceBtn.textContent = '🎤 Voice Chat';
    };
    recognition.onerror = () => {
      recognizing = false;
      voiceBtn.textContent = '🎤 Voice Chat';
    };
    recognition.onresult = e => {
      const t = e.results[0][0].transcript;
      userInput.value = t;
      sendMessage();
    };
    voiceBtn.onclick = () => {
      if (!recognition) return alert('SpeechRecognition not supported');
      recognizing ? recognition.stop() : recognition.start();
    };
  } else {
    voiceBtn.disabled = true;
    voiceBtn.title = 'SpeechRecognition not supported';
  }

  // File upload & hex preview
  fileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) {
      fileHexPreview.textContent = '';
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;
      // Check if file is binary (simple heuristic: non-text characters)
      const bytes = new Uint8Array(arrayBuffer);
      let isBinary = false;
      for (let i = 0; i < Math.min(bytes.length, 1000); i++) {
        if (bytes[i] === 0) {
          isBinary = true;
          break;
        }
      }
      if (isBinary) {
        // Show hex preview (first 512 bytes)
        const hex = [];
        for (let i = 0; i < Math.min(bytes.length, 512); i++) {
          const h = bytes[i].toString(16).padStart(2, '0');
          hex.push(h);
          if ((i + 1) % 16 === 0) hex.push('\n');
          else hex.push(' ');
        }
        fileHexPreview.textContent = hex.join('').toUpperCase();
      } else {
        // Show text preview (truncate if long)
        const text = new TextDecoder().decode(bytes);
        fileHexPreview.textContent = text.length > 1000 ? text.slice(0, 1000) + '...' : text;
      }
    };
    reader.readAsArrayBuffer(file);
  });

  // Load GPT-2 tokenizer and model
  append('Loading GPT-2 AI model... Please wait.', 'bot');
  try {
    tokenizer = await window.transformers.AutoTokenizer.fromPretrained('gpt2');
    model = await window.transformers.AutoModelForCausalLM.fromPretrained('gpt2');
    gptReady = true;
    append('GPT-2 AI model loaded! Test worked!', 'bot');
  } catch (e) {
    append('Failed to load GPT-2 model. Falling back to dictionary.', 'bot');
    console.error('GPT-2 load error:', e);
  }

  userInput.focus();
})();
</script>
</body>
</html>
