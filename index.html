<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>PetGPT Ultimate</title>
<script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0/dist/transformers.min.js"></script>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body { height:100%; font-family:Arial,sans-serif; background:#1e1e1e; color:white; display:flex; flex-direction:column; }
  header, footer { background:#007acc; padding:16px; text-align:center; font-size:20px; flex-shrink:0; }
  #chat { flex:1; overflow-y:auto; padding:10px; background:#2b2b2b; display:flex; flex-direction:column; }
  .message { margin:6px 0; padding:8px; border-radius:6px; max-width:75%; word-wrap:break-word; }
  .user { background:#3a3a3a; align-self:flex-end; }
  .bot { background:#007acc; align-self:flex-start; }
  #controls { display:flex; flex-wrap:wrap; gap:6px; padding:10px; background:#111; border-top:1px solid #444; flex-shrink:0; }
  #userInput { flex:1 1 200px; min-width:120px; padding:8px; border:none; border-radius:4px; background:#333; color:#eee; }
  button, input[type="file"] { padding:8px 12px; border:none; border-radius:4px; background:#007acc; color:white; cursor:pointer; flex-shrink:0; }
  input[type="file"] { background:#444; }
  .hex-preview { font-family:monospace; font-size:12px; background:#111; color:#0f0; padding:6px; border-radius:4px; overflow-x:auto; max-width:100%; }
  @media(max-width:600px){ #controls{ flex-direction:column; } #userInput{ width:100%; } }
</style>
</head>
<body>

<header>🐾 PetGPT Ultimate</header>
<div id="chat"><div><strong>PetGPT:</strong> Hello! I'm ready to chat.</div></div>

<div id="controls">
  <input id="userInput" placeholder="Type your message..." autocomplete="off" />
  <button id="sendBtn">Send</button>
  <button id="resetBtn">Reset Memory</button>
  <button id="voiceBtn">🎤 Voice Chat</button>
  <input type="file" id="fileUpload" title="Upload any file" />
</div>

<footer>© 2025 PetGPT</footer>

<script>
(async () => {
  const chat = document.getElementById('chat');
  const ui = document.getElementById('userInput');
  const btSend = document.getElementById('sendBtn');
  const btReset = document.getElementById('resetBtn');
  const btVoice = document.getElementById('voiceBtn');
  const fu = document.getElementById('fileUpload');

  let memory = JSON.parse(localStorage.getItem('petgpt-memory') || '{}');
  let tokenizer, model, gptReady = false;

  const fallback = {
    hello: "Hi there!",
    bye: "Goodbye!",
    "how are you": "I'm fine, thanks!"
  };

  function append(msg, cls, isHtml=false){
    const d=document.createElement('div');
    d.className='message '+cls;
    isHtml ? d.innerHTML = msg : d.textContent = msg;
    chat.appendChild(d);
    chat.scrollTop = chat.scrollHeight;
  }

  function saveMem(){ localStorage.setItem('petgpt-memory', JSON.stringify(memory)); }

  async function getReply(text){
    const t=text.toLowerCase();
    if(t.startsWith('remember:')){
      const [k,v]=t.slice(9).split('=').map(s=>s.trim());
      if(k&&v){ memory[k]=v; saveMem(); return `Okay, I'll remember ${k}`; }
      return 'Use format: remember:key=value';
    }
    for(let k in memory) if(t.includes(k)) return `You told me ${k} = ${memory[k]}`;
    for(let k in fallback) if(t.includes(k)) return fallback[k];
    if(gptReady){
      try {
        const enc = await tokenizer.encode(text);
        const out = await model.generate(enc.inputIds, {max_new_tokens:50, do_sample:true, temperature:0.7, top_p:0.9});
        let dec = await tokenizer.decode(out[0]);
        dec = dec.replace(text, '').trim();
        return dec || "(no response)";
      } catch(e){ console.error(e); }
    }
    return "I don't understand.";
  }

  async function send(){
    const t=ui.value.trim();
    if(!t) return;
    append('You: '+t, 'user'); ui.value='...'; ui.disabled=true; btSend.disabled=true;
    try{ const r=await getReply(t); append('PetGPT: '+r,'bot'); }
    catch(e){ append('PetGPT: Error occurred','bot'); console.error(e);}
    ui.disabled=false; btSend.disabled=false; ui.focus();
  }

  btSend.onclick = send;
  ui.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); send(); } });
  btReset.onclick = ()=>{ if(confirm('Clear memory?')){ localStorage.clear(); memory={}; chat.innerHTML=''; append('Memory cleared.','bot'); }};
  btVoice.onclick = ()=>{
    if(!('SpeechRecognition' in window|| 'webkitSpeechRecognition' in window)) return alert('Voice not supported');
    const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
    const rec = new SR();
    rec.lang='en-US'; rec.onresult = e=>{ ui.value=e.results[0][0].transcript; send(); };
    rec.start();
  };

  fu.onchange = e=>{
    const f=e.target.files[0];
    if(!f)return;
    const rd=new FileReader();
    function toHex(buf){
      const b=new Uint8Array(buf.slice(0,256));
      return Array.from(b).map(x=>x.toString(16).padStart(2,'0')).join(' ');
    }
    rd.onload = ev=>{
      const txt=ev.target.result;
      const np=txt.replace(/[\x20-\x7E]/g,'').length;
      if(np/txt.length>0.3){ readBin(); }
      else {
        append(`<b>File (text):</b> ${f.name}`,'bot',true);
        append(txt.length>500?txt.substr(0,500)+'...':txt,'bot');
        ui.value=txt.substr(0,500);
      }
    }
    rd.onerror = ()=>{append('⚠️ Text read failed, reading binary...','bot'); readBin();}
    const readBin=()=>{
      const r2=new FileReader();
      r2.onload = ev=>{ append(`<b>File (bin):</b> ${f.name}`,'bot',true); append(`<pre class="hex-preview">${toHex(ev.target.result)}</pre>`,'bot',true); };
      r2.readAsArrayBuffer(f);
    }
    rd.readAsText(f); fu.value='';
  };

  append('Loading GPT-2 model...','bot');
  try{
    tokenizer = await window.transformers.AutoTokenizer.fromPretrained("gpt2");
    model = await window.transformers.AutoModelForCausalLM.fromPretrained("gpt2");
    gptReady = true;
    append('GPT-2 loaded: I’m ready!','bot');
  } catch(e){
    append('GPT-2 failed. Using fallback.','bot');
    console.error(e);
  }
})();
</script>

</body>
</html>
