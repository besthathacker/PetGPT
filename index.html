<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PetGPT Ultimate</title>

<!-- PWA Manifest & Icon -->
<link rel="manifest" href="manifest.json" />
<link rel="icon" href="petgpt-icon-512.png" type="image/png" />
<meta name="theme-color" content="#000000" />

<style>
  /* Reset & base */
  * { box-sizing: border-box; }
  body, html {
    margin: 0; padding: 0; height: 100vh; font-family: Arial, sans-serif;
    background: #121212; color: #eee; display: flex; overflow: hidden;
  }
  /* Layout */
  #sidebar {
    width: 280px; background: #1f1f1f; border-right: 2px solid #444;
    display: flex; flex-direction: column; padding: 10px;
  }
  #sidebar h2 {
    margin: 0 0 10px 0; text-align: center; color: #68a;
  }
  #chatList {
    flex-grow: 1; overflow-y: auto; border: 1px solid #333; background: #222;
    padding: 5px; border-radius: 6px;
  }
  #chatList div.chat-item {
    background: #2a2a2a; margin-bottom: 6px; padding: 8px 6px; border-radius: 4px;
    cursor: pointer; display: flex; align-items: center; justify-content: space-between;
    color: #ccc;
  }
  #chatList div.chat-item.active {
    background: #4466aa;
    color: white;
  }
  #chatList div.chat-item input {
    flex-grow: 1; background: transparent; border: none; color: white;
    font-size: 1rem; outline: none;
  }
  #chatControls {
    margin-top: 10px; display: flex; gap: 6px;
  }
  #chatControls button {
    flex-grow: 1; padding: 8px; border: none; background: #357; color: white;
    cursor: pointer; border-radius: 4px;
  }
  #chatControls button:disabled {
    background: #555; cursor: not-allowed;
  }
  /* Main chat area */
  #main {
    flex-grow: 1; display: flex; flex-direction: column; background: #1e1e1e;
  }
  #chatHeader {
    padding: 12px; background: #222; border-bottom: 1px solid #444;
    display: flex; justify-content: space-between; align-items: center;
  }
  #chatTitle {
    font-size: 1.3rem; color: #aaf;
    flex-grow: 1; user-select: none;
  }
  #renameChatBtn, #deleteChatBtn {
    background: #4488cc; border: none; color: white; padding: 6px 12px;
    margin-left: 6px; border-radius: 4px; cursor: pointer;
  }
  #renameChatBtn:disabled, #deleteChatBtn:disabled {
    background: #555; cursor: not-allowed;
  }
  #chatArea {
    flex-grow: 1; overflow-y: auto; padding: 10px;
    display: flex; flex-direction: column; gap: 8px;
    background: #111;
  }
  .message {
    max-width: 70%; padding: 10px 14px; border-radius: 8px;
    word-wrap: break-word; white-space: pre-wrap;
  }
  .message.user {
    background: #2b4; align-self: flex-end; color: #010;
  }
  .message.bot {
    background: #3466bb; align-self: flex-start; color: white;
  }
  /* Input area */
  #inputArea {
    display: flex; padding: 10px; background: #222; border-top: 1px solid #444;
    gap: 6px; align-items: center;
  }
  #userInput {
    flex-grow: 1; padding: 8px 12px; border-radius: 6px; border: none;
    font-size: 1rem; background: #333; color: white;
  }
  #userInput::placeholder {
    color: #aaa;
  }
  button#sendBtn, button#voiceBtn, button#uploadBtn, button#imgGenBtn {
    background: #357; border: none; color: white;
    padding: 8px 12px; border-radius: 6px; cursor: pointer;
    user-select: none;
  }
  button:disabled {
    background: #555; cursor: not-allowed;
  }
  /* File input hidden */
  #fileInput {
    display: none;
  }
  /* Personality selector */
  #personalitySelect {
    margin-left: 8px; background: #333; color: white; border: none; border-radius: 4px;
    padding: 6px;
    font-size: 1rem;
    user-select: none;
  }
  /* Filters */
  #filterArea {
    margin-top: 4px; padding: 6px 10px; background: #222; color: #ccc;
    font-size: 0.9rem; border-top: 1px solid #444;
  }
  /* Image modal */
  #imageModal {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: none; flex-direction: column; align-items: center; justify-content: center;
    z-index: 1000; padding: 10px;
  }
  #imageModal.visible {
    display: flex;
  }
  #imageModalContent {
    background: #222; padding: 12px; border-radius: 8px; max-width: 90vw; max-height: 80vh;
    display: flex; flex-direction: column; align-items: center;
  }
  #imagePreview {
    max-width: 100%; max-height: 60vh; border-radius: 6px; margin-bottom: 12px;
    background: black;
  }
  #imagePrompt {
    width: 100%; padding: 8px; border-radius: 6px; border: none; font-size: 1rem;
    margin-bottom: 8px; background: #333; color: white;
  }
  #imageControls {
    display: flex; gap: 10px; width: 100%; justify-content: space-between;
    flex-wrap: wrap;
  }
  #imageControls > * {
    flex-grow: 1;
    min-width: 120px;
  }
  label {
    font-size: 0.85rem;
    display: flex; flex-direction: column; gap: 4px; color: #ccc;
  }
  input[type=range] {
    width: 100%;
  }
  #generateImageBtn, #closeImageModalBtn {
    padding: 8px 12px; border-radius: 6px; border: none;
    cursor: pointer; background: #357; color: white;
    user-select: none;
  }
</style>

</head>
<body>

<div id="sidebar" role="navigation" aria-label="Chat list and controls">
  <h2>PetGPT Chats</h2>
  <div id="chatList" role="listbox" tabindex="0" aria-label="Chats list"></div>
  <div id="chatControls">
    <button id="newChatBtn" aria-label="Create new chat">+ New Chat</button>
    <button id="clearMemoryBtn" aria-label="Clear all chat memory">Clear Memory</button>
  </div>
  <div id="filterArea" aria-label="Chat filters and options">
    Filter: <input type="text" id="chatFilterInput" placeholder="Search chats or messages" aria-label="Chat search filter" />
    <select id="personalitySelect" aria-label="Personality selection">
      <option value="friendly">Friendly</option>
      <option value="roast">Roast (on request)</option>
      <option value="formal">Formal</option>
    </select>
  </div>
</div>

<div id="main" role="main">
  <div id="chatHeader" aria-live="polite">
    <div id="chatTitle" contenteditable="true" role="textbox" aria-label="Chat title" spellcheck="false">New Chat</div>
    <button id="renameChatBtn" aria-label="Rename chat">Rename</button>
    <button id="deleteChatBtn" aria-label="Delete chat">Delete</button>
  </div>

  <div id="chatArea" aria-live="polite" aria-relevant="additions" role="log"></div>

  <div id="inputArea">
    <input type="text" id="userInput" aria-label="Message input" placeholder="Type your message..." autocomplete="off" />
    <button id="sendBtn" aria-label="Send message">Send</button>
    <button id="voiceBtn" aria-label="Start voice input">üé§</button>
    <button id="uploadBtn" aria-label="Upload file">üìé</button>
    <button id="imgGenBtn" aria-label="Generate or edit image">üñºÔ∏è</button>
    <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.gif,.bmp,.pdf,.txt,.js,.py,.json,.html,.css,.cpp,.java,.c,.ts,.md" aria-hidden="true" />
  </div>
</div>

<!-- Image generation & editing modal -->
<div id="imageModal" role="dialog" aria-modal="true" aria-labelledby="imageModalTitle">
  <div id="imageModalContent">
    <h3 id="imageModalTitle" style="color:white;">Image Generation & Editing</h3>
    <img id="imagePreview" alt="Image preview" />
    <textarea id="imagePrompt" placeholder="Enter prompt or instructions here..." rows="3"></textarea>
    <div id="imageControls">
      <label>Width: <input type="range" id="imgWidth" min="256" max="768" step="64" value="512" /></label>
      <label>Height: <input type="range" id="imgHeight" min="256" max="768" step="64" value="512" /></label>
      <label>Steps: <input type="range" id="imgSteps" min="5" max="50" step="1" value="25" /></label>
      <label>Guidance Scale: <input type="range" id="imgGuidance" min="1" max="20" step="0.5" value="7.5" /></label>
    </div>
    <button id="generateImageBtn">Generate/Edit</button>
    <button id="closeImageModalBtn" style="margin-top:8px;background:#aa3333;">Close</button>
  </div>
</div>

<script type="module">
import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.2.1/dist/transformers';

// Model variable
let generator;
import { DiffusionPipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/diffusers/dist/diffusers.min.js';

  let pipe;

  async function loadDiffusers() {
    pipe = await DiffusionPipeline.from_pretrained('Xenova/stable-diffusion', {
      scheduler: 'ddim', // or 'pndm', 'euler'
    });
    console.log('Stable Diffusion loaded');
  }

  async function generateImage(prompt, width = 512, height = 512, steps = 25, guidanceScale = 7.5) {
    if (!pipe) {
      console.error("Pipeline not loaded.");
      return;
    }
    const image = await pipe(prompt, {
      width,
      height,
      num_inference_steps: steps,
      guidance_scale: guidanceScale,
    });
    document.getElementById('imagePreview').src = image.toDataURL(); // Update your <img> preview
  }

  // Trigger loading on page load
  document.addEventListener('DOMContentLoaded', () => {
    loadDiffusers();

    // Hook up generate button
    document.getElementById('generateImageBtn').addEventListener('click', () => {
      const prompt = document.getElementById('imagePrompt').value;
      const width = parseInt(document.getElementById('imgWidth').value);
      const height = parseInt(document.getElementById('imgHeight').value);
      const steps = parseInt(document.getElementById('imgSteps').value);
      const guidance = parseFloat(document.getElementById('imgGuidance').value);

      generateImage(prompt, width, height, steps, guidance);
    });
  });
// Persistent chat data structure
let chats = [];
let activeChatId = null;

// Load chats from localStorage or initialize
function loadChats() {
  const stored = localStorage.getItem('petgpt_chats');
  if (stored) {
    chats = JSON.parse(stored);
    if (chats.length > 0) activeChatId = chats[0].id;
  } else {
    createNewChat();
  }
}

// Save chats to localStorage
function saveChats() {
  localStorage.setItem('petgpt_chats', JSON.stringify(chats));
}

// Generate unique ID for chats
function generateId() {
  return 'chat_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
}

// Create new chat
function createNewChat() {
  const id = generateId();
  const newChat = { id, title: 'New Chat', messages: [] };
  chats.unshift(newChat);
  activeChatId = id;
  saveChats();
  renderChatList();
  renderActiveChat();
}

// Delete chat by id
function deleteChat(id) {
  chats = chats.filter(c => c.id !== id);
  if (activeChatId === id) {
    activeChatId = chats.length > 0 ? chats[0].id : null;
  }
  saveChats();
  renderChatList();
  renderActiveChat();
}

// Rename chat by id
function renameChat(id, newTitle) {
  const chat = chats.find(c => c.id === id);
  if (chat) {
    chat.title = newTitle;
    saveChats();
    renderChatList();
    renderActiveChatTitle();
  }
}

// Render chat list in sidebar
function renderChatList(filterText = '') {
  const list = document.getElementById('chatList');
  list.innerHTML = '';
  chats.forEach(chat => {
    if (filterText && !chat.title.toLowerCase().includes(filterText.toLowerCase()) && !chat.messages.some(m => m.text.toLowerCase().includes(filterText.toLowerCase()))) {
      return;
    }
    const div = document.createElement('div');
    div.className = 'chat-item' + (chat.id === activeChatId ? ' active' : '');
    div.dataset.id = chat.id;

    const titleInput = document.createElement('input');
    titleInput.type = 'text';
    titleInput.value = chat.title;
    titleInput.spellcheck = false;
    titleInput.addEventListener('change', () => {
      renameChat(chat.id, titleInput.value.trim() || 'Untitled Chat');
    });
    div.appendChild(titleInput);

    div.addEventListener('click', () => {
      if (activeChatId !== chat.id) {
        activeChatId = chat.id;
        renderChatList();
        renderActiveChat();
      }
    });

    list.appendChild(div);
  });
}

// Render active chat messages
function renderActiveChat() {
  const chatArea = document.getElementById('chatArea');
  chatArea.innerHTML = '';
  if (!activeChatId) {
    document.getElementById('chatTitle').textContent = '';
    disableChatButtons(true);
    return;
  }
  disableChatButtons(false);

  const chat = chats.find(c => c.id === activeChatId);
  if (!chat) return;

  document.getElementById('chatTitle').textContent = chat.title;

  chat.messages.forEach(msg => {
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message ' + (msg.role === 'user' ? 'user' : 'bot');
    msgDiv.textContent = msg.text;
    chatArea.appendChild(msgDiv);
  });

  chatArea.scrollTop = chatArea.scrollHeight;
}

// Render just the chat title editable
function renderActiveChatTitle() {
  const chat = chats.find(c => c.id === activeChatId);
  if (chat) {
    document.getElementById('chatTitle').textContent = chat.title;
  }
}

// Enable or disable chat buttons based on if chat exists
function disableChatButtons(disable) {
  document.getElementById('renameChatBtn').disabled = disable;
  document.getElementById('deleteChatBtn').disabled = disable;
  document.getElementById('sendBtn').disabled = disable;
  document.getElementById('userInput').disabled = disable;
  document.getElementById('voiceBtn').disabled = disable;
  document.getElementById('uploadBtn').disabled = disable;
  document.getElementById('imgGenBtn').disabled = disable;
}

// Add message to active chat and save
function addMessageToActiveChat(role, text) {
  if (!activeChatId) return;
  const chat = chats.find(c => c.id === activeChatId);
  if (!chat) return;
  chat.messages.push({ role, text });
  saveChats();
  renderActiveChat();
}

// Handle sending user message and getting bot response
async function sendMessage() {
  const input = document.getElementById('userInput');
  const text = input.value.trim();
  if (!text) return;

  addMessageToActiveChat('user', text);
  input.value = '';
  disableChatButtons(true);

  try {
    const response = await generateResponse(text);
    addMessageToActiveChat('bot', response);
  } catch (e) {
    addMessageToActiveChat('bot', 'Error: ' + e.message);
  } finally {
    disableChatButtons(false);
    document.getElementById('userInput').focus();
  }
}

// Use GPT-2 text-generation pipeline to generate response
async function generateResponse(prompt) {
  if (!generator) {
    generator = await pipeline('text-generation', 'Xenova/gpt2');
  }
  // We feed the prompt, max new tokens to generate
  const output = await generator(prompt, { max_new_tokens: 100 });
  return output[0].generated_text.substring(prompt.length).trim();
}

// Voice input setup
function setupVoiceInput() {
  if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
    document.getElementById('voiceBtn').disabled = true;
    return;
  }
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = 'en-US';

  recognition.onresult = (event) => {
    const speechResult = event.results[0][0].transcript;
    const input = document.getElementById('userInput');
    input.value = speechResult;
    input.focus();
  };

  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
  };

  document.getElementById('voiceBtn').onclick = () => {
    recognition.start();
  };
}

// File upload & processing
function setupFileUpload() {
  const fileInput = document.getElementById('fileInput');
  const uploadBtn = document.getElementById('uploadBtn');

  uploadBtn.onclick = () => {
    fileInput.click();
  };

  fileInput.onchange = async () => {
    const file = fileInput.files[0];
    if (!file) return;

    const reader = new FileReader();

    // Determine file type and read accordingly
    if (file.type.startsWith('image/')) {
      reader.readAsDataURL(file);
      reader.onload = () => {
        addMessageToActiveChat('user', '[Image uploaded]');
        // optionally show image or send to image generation model
      };
    } else if (file.type === 'application/pdf') {
      reader.readAsArrayBuffer(file);
      reader.onload = () => {
        addMessageToActiveChat('user', '[PDF uploaded]');
        // optionally parse text if you want to extend
      };
    } else {
      reader.readAsText(file);
      reader.onload = () => {
        const text = reader.result;
        addMessageToActiveChat('user', `[File uploaded: ${file.name}]\n` + text);
      };
    }
  };
}

// Image generation & editing modal logic placeholder (needs integration with diffusers.js or similar)
// For now just show/hide modal
function setupImageModal() {
  const imgGenBtn = document.getElementById('imgGenBtn');
  const modal = document.getElementById('imageModal');
  const closeBtn = document.getElementById('closeImageModalBtn');
  const generateBtn = document.getElementById('generateImageBtn');
  const imagePreview = document.getElementById('imagePreview');
  const imagePrompt = document.getElementById('imagePrompt');

  imgGenBtn.onclick = () => {
    imagePrompt.value = '';
    imagePreview.src = '';
    modal.classList.add('visible');
  };

  closeBtn.onclick = () => {
    modal.classList.remove('visible');
  };

  generateBtn.onclick = () => {
    const prompt = imagePrompt.value.trim();
    if (!prompt) {
      alert('Please enter a prompt for image generation or editing.');
      return;
    }
    alert('Image generation functionality not implemented in this example.');
    // Here you would call diffusers.js pipeline or similar for offline image generation/editing
  };
}

// Chat title rename handler from header contenteditable
function setupChatTitleRename() {
  const chatTitle = document.getElementById('chatTitle');
  const renameBtn = document.getElementById('renameChatBtn');

  renameBtn.onclick = () => {
    chatTitle.focus();
  };

  chatTitle.addEventListener('blur', () => {
    if (!activeChatId) return;
    const newTitle = chatTitle.textContent.trim() || 'Untitled Chat';
    renameChat(activeChatId, newTitle);
  });

  // Prevent new lines in editable div
  chatTitle.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      chatTitle.blur();
    }
  });
}

// New chat button
function setupNewChatButton() {
  document.getElementById('newChatBtn').onclick = () => {
    createNewChat();
  };
}

// Delete chat button
function setupDeleteChatButton() {
  document.getElementById('deleteChatBtn').onclick = () => {
    if (!activeChatId) return;
    if (confirm('Are you sure you want to delete this chat?')) {
      deleteChat(activeChatId);
    }
  };
}

// Clear memory button
function setupClearMemoryButton() {
  document.getElementById('clearMemoryBtn').onclick = () => {
    if (confirm('Are you sure you want to clear all chat memory? This cannot be undone.')) {
      chats = [];
      activeChatId = null;
      saveChats();
      renderChatList();
      renderActiveChat();
    }
  };
}

// Filter input for chat list
function setupFilterInput() {
  const filterInput = document.getElementById('chatFilterInput');
  filterInput.oninput = () => {
    renderChatList(filterInput.value.trim());
  };
}

// Send button and enter key for input
function setupSendMessage() {
  const sendBtn = document.getElementById('sendBtn');
  const userInput = document.getElementById('userInput');

  sendBtn.onclick = () => sendMessage();

  userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
}

// Personality selector (just a placeholder here for your custom logic)
function setupPersonalitySelector() {
  const selector = document.getElementById('personalitySelect');
  selector.onchange = () => {
    // Add any personality filter or prompt modification logic here
    console.log('Personality set to', selector.value);
  };
}

// Initial setup function
async function init() {
  loadChats();
  renderChatList();
  renderActiveChat();
  setupVoiceInput();
  setupFileUpload();
  setupImageModal();
  setupChatTitleRename();
  setupNewChatButton();
  setupDeleteChatButton();
  setupClearMemoryButton();
  setupFilterInput();
  setupSendMessage();
  setupPersonalitySelector();

  // Preload GPT-2 model asynchronously
  try {
    generator = await pipeline('text-generation', 'Xenova/gpt2');
    console.log('GPT-2 model loaded');
  } catch (e) {
    console.error('Failed to load GPT-2 model:', e);
  }
}

// Start app
init();
</script>

</body>
</html>
